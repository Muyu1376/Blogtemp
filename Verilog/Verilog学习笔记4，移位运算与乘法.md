## Verilog学习笔记4，移位运算与乘法

### 题目

已知d为一个8位数，请在每个时钟周期分别输出该数乘1/3/7/8,并输出一个信号通知此时刻输入的d有效（d给出的信号的上升沿表示写入有效）

![](https://uploadfiles.nowcoder.com/images/20220315/110_1647318289820/1A8A63B78DE007D1361C622558D99390)

![](https://uploadfiles.nowcoder.com/images/20220315/110_1647318319333/C0A9FB65EE4D95CB5989F19D204C8C3D)

### 移位运算符

`<<``>>`

移位运算符是有两个操作数的双目运算符

移位可以实现**无符号数**的**乘除法**和**有符号数**的**乘法**，但是要注意是否为有符号数或者是否超出数据表示范围

在讨论乘法问题之前，先讨论一下**原码补码反码**的有关问题

机器数：一个数在计算机的存储形式是二进制数，机器数是有符号，在计算机中用机器数的最高位存放符号位，0表示正数，1表示负数。

正数的原码=反码=补码

负数反码是原码最高位即符号位保持不变，其余位分别取反

负数的补码是在反码的基础上最低位+1



移位运算实际上是进行的**补零**操作,因此不存在循环移位

`<<`左移位即在低位补零，无符号数或有符号数的乘法，左移一位相当于乘2

`>>`右移位即在高位补零，实现无符号数的除法，右移一位相当于除2

```verilog
x=4'b0010
x<<1=4'b0100
x>>1=4'b0001
```



至于为什么不能实现有符号数的除法，原因在于其补零

```verilog
x=4'b1010
x<<1=4'b0100
x>>1=4'b0101
```

有符号数用补码表示，在补码中，负数的符号位是1，但是右移的时候补了0，因此产生了错误



### 拼接运算符

`{}`是拼接运算符,能够实现**拼接和复制**操作

```verilog
a=2'b01;
b=3'b101；

c={a,b}=5'b01101;//拼接两个变量
d={4'b0101,b}=7'b0101101;//拼接数字和变量
e={2{a}}=4'b0101;//对a进行复制操作，复制了两次
```

拼接和复制操作也可以一起使用。



利用拼接运算符也可以实现有符号数的乘除法以及无符号数的**乘除法**

即在数据上拼接0

```verilog
a=4'b1101;

b={a[2:0],1'b0}=4'b1010;//乘法
c={1'b0,a[3:1]}=4'b0110;//无符号数除法
d={1'b1,a[3:1]}=4'b1110;//有符号数除法
e={a[3],a[3:1]}=4'b1110;//除法
```



### 题目分析

根据时序图分析，要对输入实现寄存，只有在grant信号的上升沿的输入，才会在接下来的四个时钟周期中进行计算输出。

在`grant`不为上升沿的时候,即使输入发生改变，也不会对输出产生影响。

因此题目中可以采用计时器`cnt`，同时还需要一个寄存变量`temp`来存储在上升沿时刻grant的数值。



### 代码

~~~verilog
`timescale 1ns/1ns
module multi_sel(
input [7:0]d ,
input clk,
input rst,
output reg input_grant,
output reg [10:0]out
);
//*************code***********//
    reg    [1:0]    cnt;
    reg    [7:0]    d_temp;
    always@(posedge clk or negedge rst)begin 
        if(!rst)begin
            cnt <= 0;
            d_temp <=0;
            out <=0;
            input_grant <=0;
        end
        else begin
            cnt <= cnt+1;
            case(cnt)
                2'b00: begin
                    d_temp <= d;
                    input_grant <=1;
                    out <= d;
                end
                2'b01: begin
                    
                    input_grant <=0;
                    out <= d_temp << 1 +d_temp;
                end
                2'b10: begin
                    
                    input_grant <=0;
                    out <= d_temp << 3 -d_temp;
                end
                2'b10: begin
                    
                    input_grant <=0;
                    out <= d_temp << 3;
                end
            endcase
        end
    end
//*************code***********//
endmodule
~~~

笔者在编写代码的时候出现了阻塞赋值与非阻塞赋值的相关错误，在代码第25行，将d_temp赋值给了out，但是由于采用非阻塞赋值，此时的d_temp!=d,造成输出错误。

### 阻塞赋值与非阻塞赋值

**阻塞赋值**：前面语句执行完，才可执行下一条语句，即将系统的运行阻塞住，停顿下来

**非阻塞赋值**：always块内，赋值语句同时执行

注：

1. 在使用组合逻辑电路时使用阻塞赋值
2. 在描述时序逻辑电路时使用非阻塞赋值
3. 阻塞赋值与非阻塞赋值不要同时出现在同一个always块内。即要么全部使用阻塞赋值要么全部使用非阻塞赋值，或者将阻塞赋值与非阻塞赋值放置于不同always块内书写